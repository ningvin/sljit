"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3],{8675:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"general/use-cases/overview","title":"Overview","description":"Determining when to use JIT compilation.","source":"@site/../general/use-cases/overview.md","sourceDirName":"general/use-cases","slug":"/general/use-cases/overview","permalink":"/sljit/docs/general/use-cases/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/zherczeg/sljit/docs/docs/../general/use-cases/overview.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"description":"Determining when to use JIT compilation."},"sidebar":"generalSidebar","previous":{"title":"Use Cases","permalink":"/sljit/docs/category/use-cases"},"next":{"title":"Bytecode Interpreters","permalink":"/sljit/docs/general/use-cases/bytecode-interpreters"}}');var s=t(4848),o=t(8453);const r={sidebar_position:1,description:"Determining when to use JIT compilation."},a="Overview",c={},l=[{value:"JIT Compilation in General",id:"jit-compilation-in-general",level:2},{value:"SLJIT in Particular",id:"sljit-in-particular",level:2}];function d(e){const n={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"overview",children:"Overview"})}),"\n",(0,s.jsx)(n.h2,{id:"jit-compilation-in-general",children:"JIT Compilation in General"}),"\n",(0,s.jsx)(n.p,{children:"Just like any other technique in a programmer's toolbox, just-in-time (JIT) compilation should not be blindly used. It is not a magic wand that performs miracles without drawbacks. In general, JIT compilation can decrease the number of executed instructions, thus speeding up the execution. You can for example embed constants and constant pointers, eliminating certain loads. However, this typically comes with added complexity and memory consumption. On embedded systems, large amounts of JIT-ed code might decrease the efficiency of the instruction cache."}),"\n",(0,s.jsx)(n.p,{children:"In the practical experience of SLJIT's author, JIT compilation is similar to code inlining (a static compiler optimization). It basically has the same disadvantages as well."}),"\n",(0,s.jsx)(n.p,{children:"As a rule of thumb, you should focus on the most frequently executed parts of your program. When in doubt, profile your application to see where the hotspots are located. Never JIT compile generic (especially complex) algorithms. Their C/C++ counterparts usually perform better."}),"\n",(0,s.jsx)(n.h2,{id:"sljit-in-particular",children:"SLJIT in Particular"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The execution can be continued from any LIR instruction. In other words, jumping into and out of the code is safe."}),"\n",(0,s.jsx)(n.li,{children:"The target of (conditional) jump and call instructions can be dynamically modified during the execution of the code."}),"\n",(0,s.jsx)(n.li,{children:"Constants can be modified during the execution of the code."}),"\n",(0,s.jsx)(n.li,{children:"Support for fast, non-ABI compliant function calls between JIT-ed functions. Requires only a few machine instructions and all registers are keeping their values."}),"\n",(0,s.jsx)(n.li,{children:"Move with update instructions, meaning the base register is updated before the actual load or store."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Disadvantages:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Limited number of arguments (3 machine words) for ABI compatible function calls on all platforms."}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);