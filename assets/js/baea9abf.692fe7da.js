"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[876],{1060:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>n,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"tutorial/local-variables","title":"Local Variables","description":"In some cases you are dealing with data that cannot be mapped to registers, either because it needs to be linear in memory (think of structs and arrays) or because it is simply too large to fit into the available ones.","source":"@site/../tutorial/07-local-variables.md","sourceDirName":"tutorial","slug":"/tutorial/local-variables","permalink":"/sljit/docs/tutorial/local-variables","draft":false,"unlisted":false,"editUrl":"https://github.com/zherczeg/sljit/docs/docs/../tutorial/07-local-variables.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Accessing Arrays","permalink":"/sljit/docs/tutorial/accessing-arrays"},"next":{"title":"Where To Go From Here","permalink":"/sljit/docs/tutorial/where-to-go-from-here"}}');var o=a(4848),r=a(8453);const i={},l="Local Variables",n={},c=[];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",header:"header",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"local-variables",children:"Local Variables"})}),"\n",(0,o.jsx)(t.p,{children:"In some cases you are dealing with data that cannot be mapped to registers, either because it needs to be linear in memory (think of structs and arrays) or because it is simply too large to fit into the available ones."}),"\n",(0,o.jsxs)(t.p,{children:["While you could resort to dynamic memory allocation, e.g. through a call to external function ",(0,o.jsx)(t.code,{children:"malloc"})," and the likes, there is a better way for temporary variables of fixed size: ",(0,o.jsx)(t.em,{children:"function local storage"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Local storage can be requested via the last parameter of ",(0,o.jsx)(t.code,{children:"sljit_emit_enter"})," in bytes, which in the previous examples was always zero. Under the hood, SLJIT will allocate the requested amount as a contiguous block of memory in the function's stack frame."]}),"\n",(0,o.jsx)(t.p,{children:"Due to its otherwise stackless API, SLJIT hides most of these implementation details from you. There are two ways to access this local data:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Special register ",(0,o.jsx)(t.code,{children:"SLJIT_SP"})," acts as a pointer to the base of the local data. It can ",(0,o.jsx)(t.em,{children:"only"})," be used in the form of ",(0,o.jsx)(t.code,{children:"SLJIT_MEM1(SLJIT_SP)"})," to access local data at an offset."]}),"\n",(0,o.jsxs)(t.li,{children:["If instead you need the actual address, you can use ",(0,o.jsx)(t.code,{children:"sljit_get_local_base"}),". For example, ",(0,o.jsx)(t.code,{children:"sljit_get_local_base(C, SLJIT_R0, 0, 0x40)"})," will load the address of the local data area offset by ",(0,o.jsx)(t.code,{children:"0x40"})," into ",(0,o.jsx)(t.code,{children:"R0"}),"."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsxs)(t.em,{children:["To see local variables in action, take a look at ",(0,o.jsx)(t.a,{href:"https://github.com/zherczeg/sljit/blob/master/docs/tutorial/sources/array_access.c",children:"this"})," example."]})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>l});var s=a(6540);const o={},r=s.createContext(o);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);