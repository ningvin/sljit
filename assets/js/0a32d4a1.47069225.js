"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[15],{9274:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"general/architecture","title":"Architecture","description":"The inner workings of SLJIT.","source":"@site/../general/architecture.md","sourceDirName":"general","slug":"/general/architecture","permalink":"/sljit/docs/general/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/zherczeg/sljit/docs/docs/../general/architecture.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"description":"The inner workings of SLJIT."},"sidebar":"generalSidebar","previous":{"title":"Configuration","permalink":"/sljit/docs/general/getting-started/configuration"},"next":{"title":"Use Cases","permalink":"/sljit/docs/category/use-cases"}}');var s=t(4848),r=t(8453);const o={sidebar_position:3,description:"The inner workings of SLJIT."},a="Architecture",l={},c=[{value:"Low-level Intermediate Representation",id:"low-level-intermediate-representation",level:2},{value:"Generic CPU Model",id:"generic-cpu-model",level:2},{value:"Integer Registers",id:"integer-registers",level:3},{value:"Memory Accessing",id:"memory-accessing",level:4},{value:"Signed / Unsigned Values",id:"signed--unsigned-values",level:4},{value:"Floating Point Registers",id:"floating-point-registers",level:3},{value:"Rounding",id:"rounding",level:4},{value:"Boolean Status Flags",id:"boolean-status-flags",level:3},{value:"Complex Instructions",id:"complex-instructions",level:2},{value:"Generating Functions",id:"generating-functions",level:2},{value:"Types",id:"types",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"architecture",children:"Architecture"})}),"\n",(0,s.jsx)(n.h2,{id:"low-level-intermediate-representation",children:"Low-level Intermediate Representation"}),"\n",(0,s.jsx)(n.p,{children:"Defining a LIR which provides wide range of optimization opportunities and still can be efficiently translated to machine code on all CPUs is the biggest challenge of this project.\nThose instruction forms and features which are supported on many (but not necessarily on all) architectures are carefully selected and a LIR is created from them.\nThese features are also emulated by the remaining architectures with low overhead.\nFor example, SLJIT supports various memory addressing modes and setting status register bits."}),"\n",(0,s.jsx)(n.h2,{id:"generic-cpu-model",children:"Generic CPU Model"}),"\n",(0,s.jsx)(n.p,{children:"The CPU has:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["integer registers, which can store either an ",(0,s.jsx)(n.code,{children:"int32_t"})," (4 byte) or ",(0,s.jsx)(n.code,{children:"intptr_t"})," (4 or 8 byte) value"]}),"\n",(0,s.jsx)(n.li,{children:"floating point registers, which can store either a single (4 byte) or double (8 byte) precision value"}),"\n",(0,s.jsx)(n.li,{children:"boolean status flags"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Some platforms additionally have support for vector registers, which may alias the floating point registers."}),"\n",(0,s.jsx)(n.h3,{id:"integer-registers",children:"Integer Registers"}),"\n",(0,s.jsx)(n.p,{children:"The most important rule is: when a source operand of an instruction is a register, the data type of the register must match the data type expected by an instruction."}),"\n",(0,s.jsx)(n.p,{children:"For example, the following code snippet is a valid instruction sequence:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"sljit_emit_op1(compiler, SLJIT_MOV32,\n    SLJIT_R0, 0, SLJIT_MEM1(SLJIT_R1), 0);\n// An int32_t value is loaded into SLJIT_R0\nsljit_emit_op1(compiler, SLJIT_REV32,\n    SLJIT_R0, 0, SLJIT_R0, 0);\n// the int32_t value in SLJIT_R0 is byte swapped\n// and the type of the result is still int32_t\n"})}),"\n",(0,s.jsx)(n.p,{children:"The next code snippet is not allowed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"sljit_emit_op1(compiler, SLJIT_MOV,\n    SLJIT_R0, 0, SLJIT_MEM1(SLJIT_R1), 0);\n// An intptr_t value is loaded into SLJIT_R0\nsljit_emit_op1(compiler, SLJIT_REV32,\n    SLJIT_R0, 0, SLJIT_R0, 0);\n// The result of the instruction is undefined.\n// Even crash is possible for some instructions\n// (e.g. on MIPS-64).\n"})}),"\n",(0,s.jsx)(n.p,{children:"However, it is always allowed to overwrite a register regardless of its previous value:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"sljit_emit_op1(compiler, SLJIT_MOV,\n    SLJIT_R0, 0, SLJIT_MEM1(SLJIT_R1), 0);\n// An intptr_t value is loaded into SLJIT_R0\nsljit_emit_op1(compiler, SLJIT_MOV32,\n    SLJIT_R0, 0, SLJIT_MEM1(SLJIT_R2), 0);\n// From now on SLJIT_R0 contains an int32_t\n// value. The previous value is discarded.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Type conversion instructions are provided to convert an ",(0,s.jsx)(n.code,{children:"int32_t"})," value to an ",(0,s.jsx)(n.code,{children:"intptr_t"})," value and vice versa.\nIn certain architectures these conversions are ",(0,s.jsx)(n.em,{children:"nops"})," (no instructions are emitted)."]}),"\n",(0,s.jsx)(n.h4,{id:"memory-accessing",children:"Memory Accessing"}),"\n",(0,s.jsxs)(n.p,{children:["Register arguments of ",(0,s.jsx)(n.code,{children:"SLJIT_MEM1"})," / ",(0,s.jsx)(n.code,{children:"SLJIT_MEM2"})," addressing modes must contain ",(0,s.jsx)(n.code,{children:"intptr_t"})," data."]}),"\n",(0,s.jsx)(n.h4,{id:"signed--unsigned-values",children:"Signed / Unsigned Values"}),"\n",(0,s.jsxs)(n.p,{children:["Most operations are executed in the same way regardless of if the value is signed or unsigned.\nThese operations have only one instruction form (e.g. ",(0,s.jsx)(n.code,{children:"SLJIT_ADD"})," / ",(0,s.jsx)(n.code,{children:"SLJIT_MUL"}),").\nInstructions where the result depends on the sign have two forms (e.g. integer division, long multiply)."]}),"\n",(0,s.jsx)(n.h3,{id:"floating-point-registers",children:"Floating Point Registers"}),"\n",(0,s.jsx)(n.p,{children:"Floating point registers can either contain a single or double precision value.\nSimilar to integer registers, the data type of the value stored in a source register must match the data type expected by the instruction.\nOtherwise the result is undefined (even a crash is possible)."}),"\n",(0,s.jsx)(n.h4,{id:"rounding",children:"Rounding"}),"\n",(0,s.jsx)(n.p,{children:"Similar to standard C, floating point computation results are rounded toward zero."}),"\n",(0,s.jsx)(n.h3,{id:"boolean-status-flags",children:"Boolean Status Flags"}),"\n",(0,s.jsx)(n.p,{children:"Conditional branches usually depend on the value of CPU status flags.\nThese status flags are boolean values and can be set by certain instructions."}),"\n",(0,s.jsx)(n.p,{children:"For better compatibility with CPUs without flags, SLJIT exposes only two such flags:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.strong,{children:"zero"})," (or equal) flag is set if ",(0,s.jsx)(n.code,{children:"SLJIT_SET_Z"})," was specified and the result is zero."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.strong,{children:"variable"})," flag's meaning depends on the arithmetic operation that sets it, as well as the type of flag requested. For example, ",(0,s.jsx)(n.code,{children:"SLJIT_ADD"})," supports setting the ",(0,s.jsx)(n.code,{children:"Z"}),", ",(0,s.jsx)(n.code,{children:"CARRY"})," and ",(0,s.jsx)(n.code,{children:"OVERFLOW"})," flags. The latter two will however both map to the variable flag and can thus not be requested at the same time."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Be aware that different operations give different guarantees on what state the flags will be in afterwards.\nAlso, not all flags are supported by all operations.\nFor more details, refer to ",(0,s.jsx)(n.a,{href:"https://github.com/zherczeg/sljit/blob/master/sljit_src/sljitLir.h",children:(0,s.jsx)(n.code,{children:"sljitLir.h"})}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"complex-instructions",children:"Complex Instructions"}),"\n",(0,s.jsx)(n.p,{children:'We noticed that introducing complex instructions for common tasks can improve performance.\nFor example, compare and branch instruction sequences can be optimized if certain conditions apply, but these conditions depend on the target CPU.\nSLJIT can do these optimizations, but it needs to understand the "purpose" of the generated code.\nStatic instruction analysis has a large performance overhead however, so we chose another approach: we introduced complex instruction forms for certain non-atomic tasks.\nSLJIT can optimize these instructions more efficiently since their purpose is known to the compiler.\nThese complex instruction forms can often be assembled from other SLJIT instructions, but we recommended to use them since the compiler can optimize them on certain CPUs.'}),"\n",(0,s.jsx)(n.h2,{id:"generating-functions",children:"Generating Functions"}),"\n",(0,s.jsxs)(n.p,{children:["SLJIT is often used for generating function bodies which are\ncalled from C.\nSLJIT provides two complex instructions for generating function entry and return: ",(0,s.jsx)(n.code,{children:"sljit_emit_enter"})," and ",(0,s.jsx)(n.code,{children:"sljit_emit_return"}),".\nThe ",(0,s.jsx)(n.code,{children:"sljit_emit_enter"})," function also initializes the compilation context, which specifies the current register mapping, local space size and other configurations.\nThe ",(0,s.jsx)(n.code,{children:"sljit_set_context"})," function can also set this context without emitting any machine instructions."]}),"\n",(0,s.jsxs)(n.p,{children:["This context is important since it affects the compiler, so the first instruction after a compiler is created must be either ",(0,s.jsx)(n.code,{children:"sljit_emit_enter"})," or ",(0,s.jsx)(n.code,{children:"sljit_set_context"}),".\nThe context can be changed by calling ",(0,s.jsx)(n.code,{children:"sljit_emit_enter"})," or ",(0,s.jsx)(n.code,{children:"sljit_set_context"})," again."]}),"\n",(0,s.jsx)(n.h2,{id:"types",children:"Types"}),"\n",(0,s.jsx)(n.p,{children:"SLJIT defines several types for representing data on the target platform, often times in both a signed and unsigned variant:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Integers of varying size: ",(0,s.jsx)(n.code,{children:"sljit_s8"})," / ",(0,s.jsx)(n.code,{children:"sljit_u8"}),", ",(0,s.jsx)(n.code,{children:"sljit_s16"})," / ",(0,s.jsx)(n.code,{children:"sljit_u16"}),", ",(0,s.jsx)(n.code,{children:"sljit_s32"})," / ",(0,s.jsx)(n.code,{children:"sljit_u32"})]}),"\n",(0,s.jsxs)(n.li,{children:["Machine word, capable of holding a pointer: ",(0,s.jsx)(n.code,{children:"sljit_sw"})," / ",(0,s.jsx)(n.code,{children:"sljit_uw"}),", ",(0,s.jsx)(n.code,{children:"sljit_sp"})," / ",(0,s.jsx)(n.code,{children:"sljit_up"})]}),"\n",(0,s.jsxs)(n.li,{children:["Floating point types: ",(0,s.jsx)(n.code,{children:"f32"}),", ",(0,s.jsx)(n.code,{children:"f64"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["It is recommended to use these types instead of the default C types such as ",(0,s.jsx)(n.code,{children:"long"}),", as it improves both the readability and the portability of the code."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);