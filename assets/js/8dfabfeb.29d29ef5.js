"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[377],{9709:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"tutorial/branching","title":"Branching","description":"Branching allows us to divert control flow. This can be useful to implement higher-level constructs such as conditionals and loops.","source":"@site/../tutorial/03-branching.md","sourceDirName":"tutorial","slug":"/tutorial/branching","permalink":"/sljit/docs/tutorial/branching","draft":false,"unlisted":false,"editUrl":"https://github.com/zherczeg/sljit/docs/docs/../tutorial/03-branching.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Your First Program","permalink":"/sljit/docs/tutorial/your-first-program"},"next":{"title":"Calling External Functions","permalink":"/sljit/docs/tutorial/calling-external-functions"}}');var s=n(4848),l=n(8453);const o={},r="Branching",c={},a=[];function u(t){const e={a:"a",code:"code",em:"em",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...t.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"branching",children:"Branching"})}),"\n",(0,s.jsx)(e.p,{children:"Branching allows us to divert control flow. This can be useful to implement higher-level constructs such as conditionals and loops."}),"\n",(0,s.jsxs)(e.p,{children:["Branches, also referred to as ",(0,s.jsx)(e.em,{children:"jumps"}),", come in two flavors:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Conditional:"})," only taken if a condition is met; otherwise, execution continues at the next instruction"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Unconditional:"})," always taken"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["Jumps can be emitted via calls to ",(0,s.jsx)(e.code,{children:"sljit_emit_cmp"})," (conditional) and ",(0,s.jsx)(e.code,{children:"sljit_emit_jump"})," (unconditional). Both of these functions return a pointer to ",(0,s.jsx)(e.code,{children:"struct sljit_jump"}),", which needs to be connected to a ",(0,s.jsx)(e.code,{children:"struct sljit_label"})," (the jump's target) later on."]}),"\n",(0,s.jsxs)(e.p,{children:["Labels can be emitted via calls to ",(0,s.jsx)(e.code,{children:"sljit_emit_label"})," and connected to jumps via ",(0,s.jsx)(e.code,{children:"sljit_set_label"}),". The whole mechanism is very similar to labels and gotos in C."]}),"\n",(0,s.jsx)(e.p,{children:"In order to map higher-level constructs such as conditionals and loops to SLJIT, it helps to think about them in terms of labels and (un)conditional gotos. As an example, take the following simple function body:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-c",children:"if ((a & 1) == 0)\n    return c;\nreturn b;\n"})}),"\n",(0,s.jsx)(e.p,{children:"Expressing the implicit control flow with lables and gotos yields:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"    R0 = a & 1;\n    if R0 == 0 then goto ret_c;\n    R0 = b;\n    goto out;\nret_c:\n    R0 = c;\nout:\n    return R0;\n"})}),"\n",(0,s.jsx)(e.p,{children:"This is also what higher-level language compilers do under the hood. The result can now easily be assembled with SLJIT:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-c",children:"#include \"sljitLir.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef sljit_sw (SLJIT_FUNC *func3_t)(sljit_sw a, sljit_sw b, sljit_sw c);\n\nstatic int branch(sljit_sw a, sljit_sw b, sljit_sw c)\n{\n\tvoid *code;\n\tsljit_uw len;\n\tfunc3_t func;\n\n\tstruct sljit_jump *ret_c;\n\tstruct sljit_jump *out;\n\n\t/* Create a SLJIT compiler */\n\tstruct sljit_compiler *C = sljit_create_compiler(NULL);\n\n\t/* 3 arg, 1 temp reg, 3 save reg */\n\tsljit_emit_enter(C, 0, SLJIT_ARGS3(W, W, W, W), 1, 3, 0);\n\n\t/* R0 = a & 1, S0 is argument a */\n\tsljit_emit_op2(C, SLJIT_AND, SLJIT_R0, 0, SLJIT_S0, 0, SLJIT_IMM, 1);\n\n\t/* if R0 == 0 then jump to ret_c, where is ret_c? we assign it later */\n\tret_c = sljit_emit_cmp(C, SLJIT_EQUAL, SLJIT_R0, 0, SLJIT_IMM, 0);\n\n\t/* R0 = b, S1 is argument b */\n\tsljit_emit_op1(C, SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_S1, 0);\n\n\t/* jump to out */\n\tout = sljit_emit_jump(C, SLJIT_JUMP);\n\n\t/* here is the 'ret_c' should jump, we emit a label and set it to ret_c */\n\tsljit_set_label(ret_c, sljit_emit_label(C));\n\n\t/* R0 = c, S2 is argument c */\n\tsljit_emit_op1(C, SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_S2, 0);\n\n\t/* here is the 'out' should jump */\n\tsljit_set_label(out, sljit_emit_label(C));\n\n\t/* end of function */\n\tsljit_emit_return(C, SLJIT_MOV, SLJIT_RETURN_REG, 0);\n\n\t/* Generate machine code */\n\tcode = sljit_generate_code(C, 0, NULL);\n\tlen = sljit_get_generated_code_size(C);\n\n\t/* Execute code */\n\tfunc = (func3_t)code;\n\tprintf(\"func return %ld\\n\", (long)func(a, b, c));\n\n\t/* dump_code(code, len); */\n\n\t/* Clean up */\n\tsljit_free_compiler(C);\n\tsljit_free_code(code, NULL);\n\treturn 0;\n}\n\nint main()\n{\n\treturn branch(4, 5, 6);\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsxs)(e.em,{children:["The complete source code of the example can be found ",(0,s.jsx)(e.a,{href:"https://github.com/zherczeg/sljit/blob/master/docs/tutorial/sources/branch.c",children:"here"}),"."]})}),"\n",(0,s.jsx)(e.p,{children:"Building on these basic techniques, you can further use branches to generate a loop. So, given the following function body:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-c",children:"i = 0;\nret = 0;\nfor (i = 0; i < a; ++i) {\n    ret += b;\n}\nreturn ret;\n"})}),"\n",(0,s.jsx)(e.p,{children:"You can again make the control flow explicit using labels and gotos:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"    i = 0;\n    ret = 0;\nloopstart:\n    if i >= a then goto out;\n    ret += b\n    goto loopstart;\nout:\n    return ret;\n"})}),"\n",(0,s.jsx)(e.p,{children:"And then use that to assemble the function with SLJIT:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-c",children:'#include "sljitLir.h"\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef sljit_sw (SLJIT_FUNC *func2_t)(sljit_sw a, sljit_sw b);\n\nstatic int loop(sljit_sw a, sljit_sw b)\n{\n\tvoid *code;\n\tsljit_uw len;\n\tfunc2_t func;\n\n\tstruct sljit_label *loopstart;\n\tstruct sljit_jump *out;\n\n\t/* Create a SLJIT compiler */\n\tstruct sljit_compiler *C = sljit_create_compiler(NULL);\n\n\t/* 2 arg, 2 temp reg, 2 saved reg */\n\tsljit_emit_enter(C, 0, SLJIT_ARGS2(W, W, W), 2, 2, 0);\n\n\t/* R0 = 0 */\n\tsljit_emit_op2(C, SLJIT_XOR, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_R1, 0);\n\t/* RET = 0 */\n\tsljit_emit_op1(C, SLJIT_MOV, SLJIT_RETURN_REG, 0, SLJIT_IMM, 0);\n\t/* loopstart: */\n\tloopstart = sljit_emit_label(C);\n\t/* R1 >= a --\x3e jump out */\n\tout = sljit_emit_cmp(C, SLJIT_GREATER_EQUAL, SLJIT_R1, 0, SLJIT_S0, 0);\n\t/* RET += b */\n\tsljit_emit_op2(C, SLJIT_ADD, SLJIT_RETURN_REG, 0, SLJIT_RETURN_REG, 0, SLJIT_S1, 0);\n\t/* R1 += 1 */\n\tsljit_emit_op2(C, SLJIT_ADD, SLJIT_R1, 0, SLJIT_R1, 0, SLJIT_IMM, 1);\n\t/* jump loopstart */\n\tsljit_set_label(sljit_emit_jump(C, SLJIT_JUMP), loopstart);\n\t/* out: */\n\tsljit_set_label(out, sljit_emit_label(C));\n\n\t/* return RET */\n\tsljit_emit_return(C, SLJIT_MOV, SLJIT_RETURN_REG, 0);\n\n\t/* Generate machine code */\n\tcode = sljit_generate_code(C, 0, NULL);\n\tlen = sljit_get_generated_code_size(C);\n\n\t/* Execute code */\n\tfunc = (func2_t)code;\n\tprintf("func return %ld\\n", (long)func(a, b));\n\n\t/* dump_code(code, len); */\n\n\t/* Clean up */\n\tsljit_free_compiler(C);\n\tsljit_free_code(code, NULL);\n\treturn 0;\n}\n\nint main()\n{\n\treturn loop(4, 5);\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"The other conditionals and loops can be achieved very similarly."}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsxs)(e.em,{children:["The complete source code of the example can be found ",(0,s.jsx)(e.a,{href:"https://github.com/zherczeg/sljit/blob/master/docs/tutorial/sources/loop.c",children:"here"}),"."]})})]})}function d(t={}){const{wrapper:e}={...(0,l.R)(),...t.components};return e?(0,s.jsx)(e,{...t,children:(0,s.jsx)(u,{...t})}):u(t)}},8453:(t,e,n)=>{n.d(e,{R:()=>o,x:()=>r});var i=n(6540);const s={},l=i.createContext(s);function o(t){const e=i.useContext(l);return i.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function r(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(s):t.components||s:o(t.components),i.createElement(l.Provider,{value:e},t.children)}}}]);