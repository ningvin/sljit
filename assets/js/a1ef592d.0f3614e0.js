"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[620],{1638:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"tutorial/your-first-program","title":"Your First Program","description":"To use SLJIT, simply include the sljitLir.h header in your code and link against sljitLir.c.","source":"@site/../tutorial/02-your-first-program.md","sourceDirName":"tutorial","slug":"/tutorial/your-first-program","permalink":"/sljit/docs/tutorial/your-first-program","draft":false,"unlisted":false,"editUrl":"https://github.com/zherczeg/sljit/docs/docs/../tutorial/02-your-first-program.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Overview","permalink":"/sljit/docs/tutorial/overview"},"next":{"title":"Branching","permalink":"/sljit/docs/tutorial/branching"}}');var t=r(4848),i=r(8453);const c={},d="Your First Program",o={},l=[];function a(e){const s={a:"a",code:"code",em:"em",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"your-first-program",children:"Your First Program"})}),"\n",(0,t.jsxs)(s.p,{children:["To use SLJIT, simply include the ",(0,t.jsx)(s.code,{children:"sljitLir.h"})," header in your code and link against ",(0,t.jsx)(s.code,{children:"sljitLir.c"}),".\nLet's jump right into your first program:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-c",children:'#include "sljitLir.h"\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef sljit_sw (SLJIT_FUNC *func3_t)(sljit_sw a, sljit_sw b, sljit_sw c);\n\nstatic int add3(sljit_sw a, sljit_sw b, sljit_sw c)\n{\n    void *code;\n    sljit_uw len;\n    func3_t func;\n\n    /* Create a SLJIT compiler */\n    struct sljit_compiler *C = sljit_create_compiler(NULL);\n\n    /* Start a context (function prologue) */\n    sljit_emit_enter(C,\n        0,                       /* Options */\n        SLJIT_ARGS3(W, W, W, W), /* 1 return value and 3 parameters of type sljit_sw */\n        1,                       /* 1 scratch register used */\n        3,                       /* 3 saved registers used */\n        0);                      /* 0 bytes allocated for function local variables */\n\n    /* The first argument of a function is stored in register SLJIT_S0, the 2nd in SLJIT_S1, etc. */\n    /* R0 = first */\n    sljit_emit_op1(C, SLJIT_MOV, SLJIT_R0, 0, SLJIT_S0, 0);\n\n    /* R0 = R0 + second */\n    sljit_emit_op2(C, SLJIT_ADD, SLJIT_R0, 0, SLJIT_R0, 0, SLJIT_S1, 0);\n\n    /* R0 = R0 + third */\n    sljit_emit_op2(C, SLJIT_ADD, SLJIT_R0, 0, SLJIT_R0, 0, SLJIT_S2, 0);\n\n    /* This statement moves R0 to RETURN REG and returns */\n    /* (in fact, R0 is the RETURN REG itself) */\n    sljit_emit_return(C, SLJIT_MOV, SLJIT_R0, 0);\n\n    /* Generate machine code */\n    code = sljit_generate_code(C, 0, NULL);\n    len = sljit_get_generated_code_size(C);\n\n    /* Execute code */\n    func = (func3_t)code;\n    printf("func return %ld\\n", (long)func(a, b, c));\n\n    /* dump_code(code, len); */\n\n    /* Clean up */\n    sljit_free_compiler(C);\n    sljit_free_code(code, NULL);\n\n    return 0;\n}\n\nint main()\n{\n    return add3(4, 5, 6);\n}\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Code generation with SLJIT typically starts with a call to ",(0,t.jsx)(s.code,{children:"sljit_emit_enter"}),", which generates the ",(0,t.jsx)(s.em,{children:"function prologue"}),": certain register are saved to the stack, stack space for function-local variables is allocted if requested and a call frame is established."]}),"\n",(0,t.jsxs)(s.p,{children:["This is necessary as the code generated by SLJIT wants to interoperate nicely with the other parts of your program: it can be called just like a C function pointer and you can ",(0,t.jsx)(s.a,{href:"/sljit/docs/tutorial/calling-external-functions",children:"call C functions"})," from within JIT-ed code with ease."]}),"\n",(0,t.jsxs)(s.p,{children:["The rules for interoperation are also refered to as the ",(0,t.jsx)(s.em,{children:"Application Binary Interface"}),", or ABI for short. These typically vary between different architectures and operating systems. The most common ones are:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"https://wiki.osdev.org/System_V_ABI",children:"System V ABI"})," - used by the major Unix operating systems (Linux / BSD / AIX / ...)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions?view=msvc-170",children:"Windows x64 ABI"})," - used by (you guessed it) Windows"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Luckily, SLJIT does all the heavy lifting so that you do not have to worry about platform and ABI specific stuff for the most part. If you are interested in how things work under the hood though, take a look at the ",(0,t.jsx)(s.em,{children:"calling conventions"})," sections in the ABI documentation."]}),"\n",(0,t.jsx)(s.p,{children:"SLJIT supports two types of registers (analoguous to the underlying ABIs):"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Scratch registers"})," (also known as ",(0,t.jsx)(s.em,{children:"volatile registers"}),") - may not preserve their value accross function calls"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Saved registers"})," (also known as ",(0,t.jsx)(s.em,{children:"non-volatile registers"}),") - preserve their value accross function calls"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["We declare the amount of scratch and saved registers our function will use upfront in the call to ",(0,t.jsx)(s.code,{children:"sljit_emit_enter"}),". These registers are then referred to by their names (",(0,t.jsx)(s.code,{children:"SLJIT_R0"}),", ",(0,t.jsx)(s.code,{children:"SLJIT_R1"}),", ",(0,t.jsx)(s.code,{children:"SLJIT_R2"}),", ... for scratch registers and ",(0,t.jsx)(s.code,{children:"SLJIT_S0"}),", ",(0,t.jsx)(s.code,{children:"SLJIT_S1"}),", ",(0,t.jsx)(s.code,{children:"SLJIT_S2"}),", ... for saved registers).\nAdditionally, SLJIT supports dedicated floating point and vector registers. These are referred to by ",(0,t.jsx)(s.code,{children:"SLJIT_FRN"})," / ",(0,t.jsx)(s.code,{children:"SLJIT_FSN"})," and ",(0,t.jsx)(s.code,{children:"SLJIT_VRN"})," / ",(0,t.jsx)(s.code,{children:"SLJIT_VSN"})," respectively (where ",(0,t.jsx)(s.code,{children:"N"})," is a number starting from ",(0,t.jsx)(s.code,{children:"0"}),")."]}),"\n",(0,t.jsx)(s.p,{children:"As different architectures have different amounts of registers, the amount of scratch and saved registers available varies accross them. You can query the available amount of registers with the following macros:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"SLJIT_NUMBER_OF_REGISTERS"})," (>= 12 on all supported platforms)"]}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"SLJIT_NUMBER_OF_SCRATCH_REGISTERS"})}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"SLJIT_NUMBER_OF_SAVED_REGISTERS"})," (>= 6 on all supported platforms)"]}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"SLJIT_NUMBER_OF_FLOAT_REGISTERS"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"SLJIT_NUMBER_OF_VECTOR_REGISTERS"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"SLJIT_NUMBER_OF_SAVED_VECTOR_REGISTERS"})}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Note that the different register sets may overlap, i.e. two distinct SLJIT registers may refer to the same physical register. This is especially true between scratch and saved registers of the same kind, as well as between floating point and vector registers."}),"\n",(0,t.jsxs)(s.p,{children:["A function's signature is defined using one of the ",(0,t.jsx)(s.code,{children:"SLJIT_ARGS..."})," macros. In the example above, the function declares a return type and three parameters of type ",(0,t.jsx)(s.code,{children:"W"}),", i.e. an integer of machine word width. For the other supported types, take a look at the ",(0,t.jsx)(s.code,{children:"SLJIT_ARG_TYPE_..."})," macros in ",(0,t.jsx)(s.code,{children:"sljitLir.h"}),". Parameters are passed by default in registers ",(0,t.jsx)(s.code,{children:"SLJIT_S0"})," - ",(0,t.jsx)(s.code,{children:"SLJIT_S3"})," (for integers) and ",(0,t.jsx)(s.code,{children:"SLJIT_FR0"})," - ",(0,t.jsx)(s.code,{children:"SLJIT_FR3"})," (for floating point numbers) respectively. Analoguos, the return value is passed in ",(0,t.jsx)(s.code,{children:"SLJIT_R0"})," or ",(0,t.jsx)(s.code,{children:"SLJIT_FR0"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["Most generic operations are carried out by invoking one of the ",(0,t.jsx)(s.code,{children:"sljit_emit_opN"})," functions. These typically take one target, as well as ",(0,t.jsx)(s.code,{children:"N"})," source operands."]}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"1st parameter"}),(0,t.jsx)(s.th,{children:"2nd parameter"}),(0,t.jsx)(s.th,{children:"Semantic"}),(0,t.jsx)(s.th,{children:"Example"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"r"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"0"})}),(0,t.jsxs)(s.td,{children:["The value contained in register ",(0,t.jsx)(s.code,{children:"r"}),", i.e. ",(0,t.jsx)(s.code,{children:"*r"})]}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"SLJIT_R0, 0"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"SLJIT_IMM"})}),(0,t.jsxs)(s.td,{children:["Value ",(0,t.jsx)(s.code,{children:"i"})]}),(0,t.jsxs)(s.td,{children:["The value ",(0,t.jsx)(s.code,{children:"i"})]}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"SLJIT_IMM, 17"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"SLJIT_MEM"})," / ",(0,t.jsx)(s.code,{children:"SLJIT_MEM0"})]}),(0,t.jsxs)(s.td,{children:["Address ",(0,t.jsx)(s.code,{children:"a"})]}),(0,t.jsxs)(s.td,{children:["The value at address ",(0,t.jsx)(s.code,{children:"a"})]}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"SLJIT_MEM0, &my_c_func"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"SLJIT_MEM1(r)"})}),(0,t.jsxs)(s.td,{children:["Offset ",(0,t.jsx)(s.code,{children:"o"})]}),(0,t.jsxs)(s.td,{children:["The value at address ",(0,t.jsx)(s.code,{children:"*r + o"})]}),(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"SLJIT_MEM1(SLJIT_R0), 16"}),(0,t.jsx)("br",{}),"Access the memory at the address in ",(0,t.jsx)(s.code,{children:"SLJIT_R0"})," offset by ",(0,t.jsx)(s.code,{children:"16"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"SLJIT_MEM2(r1, r2)"})}),(0,t.jsxs)(s.td,{children:["Shift ",(0,t.jsx)(s.code,{children:"s"})]}),(0,t.jsxs)(s.td,{children:["The value at address ",(0,t.jsx)(s.code,{children:"*r1 + (*r2 * (1 << s))"}),";",(0,t.jsx)("br",{}),(0,t.jsx)(s.code,{children:"s"})," must be in ",(0,t.jsx)(s.code,{children:"[0, 1, 2, 3]"})]}),(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.code,{children:"SLJIT_MEM2(SLJIT_R0, SLJIT_R1), 2"}),(0,t.jsx)("br",{}),"Access index ",(0,t.jsx)(s.code,{children:"SLJIT_R1"})," in an array of items of length ",(0,t.jsx)(s.code,{children:"2"})," byte starting at address ",(0,t.jsx)(s.code,{children:"SLJIT_R0"})]})]})]})]}),"\n",(0,t.jsxs)(s.p,{children:["Lastly, control is returned to the caller by invoking ",(0,t.jsx)(s.code,{children:"sljit_emit_return"}),"."]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,s,r)=>{r.d(s,{R:()=>c,x:()=>d});var n=r(6540);const t={},i=n.createContext(t);function c(e){const s=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),n.createElement(i.Provider,{value:s},e.children)}}}]);