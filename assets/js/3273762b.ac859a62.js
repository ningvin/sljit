"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[673],{5605:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"general/use-cases/pattern-matching/speeding-up-pcre2-with-sljit","title":"Speeding Up PCRE2 With SLJIT","description":"Adding JIT compilation via SLJIT to the PCRE2 library.","source":"@site/../general/use-cases/pattern-matching/speeding-up-pcre2-with-sljit.md","sourceDirName":"general/use-cases/pattern-matching","slug":"/general/use-cases/pattern-matching/speeding-up-pcre2-with-sljit","permalink":"/sljit/docs/general/use-cases/pattern-matching/speeding-up-pcre2-with-sljit","draft":false,"unlisted":false,"editUrl":"https://github.com/zherczeg/sljit/docs/docs/../general/use-cases/pattern-matching/speeding-up-pcre2-with-sljit.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"description":"Adding JIT compilation via SLJIT to the PCRE2 library."},"sidebar":"generalSidebar","previous":{"title":"Pattern Matching","permalink":"/sljit/docs/category/pattern-matching"},"next":{"title":"Regular Expression Engine Types","permalink":"/sljit/docs/general/use-cases/pattern-matching/regular-expression-engine-types"}}');var i=n(4848),r=n(8453);const s={sidebar_position:1,description:"Adding JIT compilation via SLJIT to the PCRE2 library."},c="Speeding Up PCRE2 With SLJIT",o={},h=[{value:"Structure of the Generated Code",id:"structure-of-the-generated-code",level:2},{value:"Single Character Repitition Optimizations",id:"single-character-repitition-optimizations",level:2},{value:"Character Class Optimizations",id:"character-class-optimizations",level:2},{value:"Literal Optimizations",id:"literal-optimizations",level:2},{value:"Summary",id:"summary",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"speeding-up-pcre2-with-sljit",children:"Speeding Up PCRE2 With SLJIT"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://www.pcre.org/",children:"PCRE2"})," is a C library for matching regular expressions.\nThis library translates patterns into byte code, and this byte code can be executed by its interpreter.\nThe library also has a just-in-time (JIT) compiler which can produce machine code from the byte code to further improve the matching performance.\nBefore going into the details of the JIT compiler, the reason of choosing byte code as an internal representation is explained first."]}),"\n",(0,i.jsx)(t.p,{children:"Regular expressions were originally designed for defining a set of words using special patterns, and engines only needed to decide whether a given word is in the set.\nEventually patterns become a list of commands, and pattern matching engines become script languages.\nToday many constructs of structured programming are available in regular expressions (pcre2pattern / perlre) such as loops (called repetitions), if-else selection (called conditional blocks), function calls (called recursions), returns and breaks (called control verbs).\nThe execution of each command is accurately defined which allows fine control over the entire matching process.\nPatterns can also store information in local variables (called capturing blocks and marks) and these variables are often available after the matching is completed.\nByte code is used as an internal representation in many script languages, and modern regular expression engines are no different.\nThere are several methods to improve the performance of byte code execution (including JIT compiling), but even the fastest script language can do very little to improve the speed of a slow bubble sort.\nHence it is recommended to carefully design patterns to avoid slow matching speed."}),"\n",(0,i.jsx)(t.h2,{id:"structure-of-the-generated-code",children:"Structure of the Generated Code"}),"\n",(0,i.jsx)(t.p,{children:"Regular expression patterns are a sequence of sub-patterns which are matched in concatenation order.\nWhen a sub-pattern matches successfully, the engine tries to match the next sub-pattern, and when its matching is failed, the engine falls back to the previous sub-pattern.\nIf the previous sub-pattern has multiple options for matching, and another option does match, the engine will try to match the next sub-pattern again.\nThis technique is called backtracking."}),"\n",(0,i.jsx)(t.p,{children:"The code generated by PCRE2 JIT is specialized for this execution order.\nFor each sub-pattern the compiler generates two code paths called matching and backtracking path.\nThe order of matching paths in the generated code is the same as the original concatenation order since the next sub-pattern must be matched after a successful match.\nHowever the backtracking paths are generated in a reversed concatenation order because the engine must fall back to the previous sub-pattern after a failed match.\nControl flow is shown in the next figure where green and red arrows show the possible control transfers from matching and backtracking paths respectively.\nDue to the code generation order described before, no jump instructions are needed for control transfers represented by horizontal arrows."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"figure1",src:n(7009).A+"",width:"718",height:"163"})}),"\n",(0,i.jsx)(t.p,{children:"The next figure shows the structure of the machine code generated from the /a(?:\\w\\d)+d/ pattern:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'\n     # Start of matching paths\n   ENTER\n     # Matching path of matching the "a" letter\n   MATCH "a", IF FAILS GOTO L6\n     # Matching path of (?:)+\n   STACK_PUSH NULL\nL1:\n     # Matching path of matching the \\w special character\n   MATCH WORD_CHARACTER, IF FAILS GOTO L5\n     # Matching path of matching the \\d special character\n   MATCH DIGIT_CHARACTER, IF FAILS GOTO L4\n     # Continue the matching path of (?:)+\n   STACK_PUSH STRING_POINTER\n   GOTO L1\nL2:\n     # Matching path of matching the "d" letter\n   MATCH "d", IF FAILS GOTO L3\n   RETURN SUCCESS\n\n     # Start of backtracking paths\n     # Backtracking path of matching the "d" letter (empty)\nL3:\n     # Backtracking path of (?:)+ (empty)\n     # Backtracking path of matching the dot special character (empty)\nL4:\n     # Backtracking path of matching the "b" letter (empty)\nL5:\n     # Continue backtracking path of (?:)+\n   STRING_POINTER = STACK_POP\n   IF STRING_POINTER != NULL GOTO L2\n     # Backtracking path of matching the "a" letter (empty)\nL6:\n   RETURN FAIL\n'})}),"\n",(0,i.jsxs)(t.p,{children:["When a matching path has only one alternative (e.g. matching the letter ",(0,i.jsx)(t.code,{children:"a"}),"), the backtracking path is often empty, i.e. no instructions are generated at all.\nSome constructs may contain the code paths of other sub-patterns.\nIn our example above, the code paths of ",(0,i.jsx)(t.code,{children:"\\w\\d"})," sub-pattern is nested into the code paths of ",(0,i.jsx)(t.code,{children:"(?:)+"}),".\nFurthermore the current position in the input is stored in the ",(0,i.jsx)(t.code,{children:"STRING_POINTER"})," variable.\nThis variable must have the correct value when the execution enters into a matching path, but it is undefined for backtracking paths.\nHence the backtracking path must restore (or set) it before jumps to a matching path.\nThis restoration can be seen in the backtracking path of ",(0,i.jsx)(t.code,{children:"(?:)+"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["More about this method can be found in this ",(0,i.jsx)(t.a,{href:"https://dl.acm.org/doi/abs/10.1145/2544137.2544146",children:"research paper"}),".\nIn the followings some optimizations done by the compiler is shown."]}),"\n",(0,i.jsx)(t.h2,{id:"single-character-repitition-optimizations",children:"Single Character Repitition Optimizations"}),"\n",(0,i.jsxs)(t.p,{children:["Sometimes multiple letters represent a single character, such as ",(0,i.jsx)(t.code,{children:"sh"})," in English or ",(0,i.jsx)(t.code,{children:"sch"})," in German.\nThese sequences cannot be broken into smaller parts, so perl calls them atomic blocks.\nAnother well known example is ",(0,i.jsx)(t.code,{children:"\\r\\n"})," which represents a single newline.\nAlthough ",(0,i.jsx)(t.code,{children:"\\r"})," and ",(0,i.jsx)(t.code,{children:"\\n"})," are also newlines, the ",(0,i.jsx)(t.code,{children:"x\\R{2}y"})," pattern does not match to ",(0,i.jsx)(t.code,{children:"x\\r\\ny"}),", because there is only one newline between ",(0,i.jsx)(t.code,{children:"x"})," and ",(0,i.jsx)(t.code,{children:"y"})," letters.\nAtomic blocks can speed up matching, since they can eliminate many retries.\nFor example ",(0,i.jsx)(t.code,{children:"a+b"})," and ",(0,i.jsx)(t.code,{children:"a++b"})," matches to the same strings since no ",(0,i.jsx)(t.code,{children:"b"})," can be present in a sequence of ",(0,i.jsx)(t.code,{children:"a"}),"-s.\nHence the engine automatically converts the repetitions to the latter form whenever it has no side effects."]}),"\n",(0,i.jsxs)(t.p,{children:["The JIT compiler can speed up repetitions followed by a single character as well.\nAn example is ",(0,i.jsx)(t.code,{children:"\\w+x"}),", where ",(0,i.jsx)(t.code,{children:"\\w+"})," cannot be converted to ",(0,i.jsx)(t.code,{children:"\\w++"})," because ",(0,i.jsx)(t.code,{children:"x"})," is included in ",(0,i.jsx)(t.code,{children:"\\w"})," character class.\nThe code generated for ",(0,i.jsx)(t.code,{children:"\\w+"})," also records the first and last occurrence of ",(0,i.jsx)(t.code,{children:"x"})," and backtracking is limited to this range.\nThis optimization has the highest efficiency when at most one ",(0,i.jsx)(t.code,{children:"x"})," is found during the repetition."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"(*SKIP)"})," control verb allows moving forward in the input.\nFor example, this verb can be used to search identifiers in a source code excluding comments and string literals.\nTo do that, the pattern should also look for comments and string literals but it skips these blocks instead of returning with a match.\nSkip can be used to improve performance as well.\nThe ",(0,i.jsx)(t.code,{children:"\\w+!"})," and ",(0,i.jsx)(t.code,{children:"\\w+(*SKIP)!"})," patterns match to the same strings because when ",(0,i.jsx)(t.code,{children:"\\w+"})," is matched to a range of characters, but the match is failed afterwards, then any other match attempts within this range must fail as well.\nTherefore the search can be resumed from the end of the range which eliminates several match attempts.\nBesides adding ",(0,i.jsx)(t.code,{children:"(*SKIP)"})," verbs to the pattern, the JIT compiler can also enhance iterators to remember the range of their last successful match, and any future matching attempts within this range triggers a fail."]}),"\n",(0,i.jsx)(t.h2,{id:"character-class-optimizations",children:"Character Class Optimizations"}),"\n",(0,i.jsx)(t.p,{children:"Checking that a character is in a set of characters (called character classes) is a frequent operation in pattern matching.\nWhen caseless mode is enabled, even a simple pattern character may match to different characters especially when UTF is enabled."}),"\n",(0,i.jsxs)(t.p,{children:["The most basic optimization is caseless compare with a single compare instruction if there is only one bit difference between the binary representation of the lower and upper case of a character.\nFor example, ascii ",(0,i.jsx)(t.code,{children:"x"})," and ",(0,i.jsx)(t.code,{children:"X"})," differs only in bit 6, so ",(0,i.jsx)(t.code,{children:"(chr|0x20)=='x'"})," performs a caseless compare, and it is faster than doing two compares.\nThis can be extended to ranges, so the ",(0,i.jsx)(t.code,{children:"[f-xF-X]"})," range can be checked with this formula: ",(0,i.jsx)(t.code,{children:"((chr|0x20)-'f')<('x'-'f')"}),".\nOptimizing these cases is no different from optimizing conditional expressions in static compilers such as GCC."]}),"\n",(0,i.jsx)(t.p,{children:"The JIT compiler also has some UTF related optimizations.\nFor example, if a class is limited to characters less than 128 in UTF8 mode, reading only the next byte is enough and it is faster than decoding the UTF8 character.\nThis optimization is not limited to the previous case, the compiler can generate specialized readers which do not decode characters outside of a given range.\nWhen invalid UTF8 parsing is enabled, the character reader first checks whether the input buffer has at least four remaining bytes.\nThis is nearly always true, and then the character can be decoded without further boundary checks since four is the size of the longest UTF8 character."}),"\n",(0,i.jsx)(t.p,{children:"The JIT compiler generates helper functions for several operations, such as decoding complex UTF cases.\nThese functions are extremely lightweight: they don't set up a call frame or save any CPU registers, and can even modify the status of the caller.\nThe effect is quite similar to inlining, except that the function is actually called.\nMust CPUs has return address predictors, so calling these functions are cheap operations."}),"\n",(0,i.jsx)(t.h2,{id:"literal-optimizations",children:"Literal Optimizations"}),"\n",(0,i.jsx)(t.p,{children:"Literals are fixed character sequences and they are often found in patterns.\nComparing them to the input is a frequent task which normally requires the same number of steps as the length of the literal.\nHowever CPU registers are often large enough to hold multiple characters so the number of comparisons can be reduced as long as the CPU can read a whole register from any starting address.\nSuch read is called unaligned access and requires hardware support."}),"\n",(0,i.jsxs)(t.p,{children:["Single Instruction Multiple Data (SIMD) operations can speed up literal searching.\nThese operations can process the input efficiently since they use large registers which can hold several input characters.\nThe JIT compiler uses SIMD for searching characters and character pairs.\nSearching a pair is based on an observation that the chance of finding a pair is often much lower than finding a single character.\nThe only condition is that the two characters of a pair must be different since searching two spaces instead of one might not give better results.\nThe compiler tries to detect the pair with the lowest match probability, so it will choose the ",(0,i.jsx)(t.code,{children:"a"})," and ",(0,i.jsx)(t.code,{children:"c"})," characters from the ",(0,i.jsx)(t.code,{children:"a.(?i:b).c"})," pattern."]}),"\n",(0,i.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(t.p,{children:["PCRE2 is among the most feature rich regular expression libraries.\nIt supports many regular expression constructs and it has many operating modes.\nIts JIT compiler tries to optimize many of these features with static compiler optimizations, and this text introduces some of these optimizations.\nBesides these optimizations, directed pattern transformations can also help to improve performance, but that is the focus of other projects such as ",(0,i.jsx)(t.a,{href:"https://github.com/zherczeg/repan",children:"repan"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},7009:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/figure1-f7e963db6a1912b8477ee35590768009.svg"},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>c});var a=n(6540);const i={},r=a.createContext(i);function s(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);